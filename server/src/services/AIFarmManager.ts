import { GoogleGenerativeAI } from '@google/generative-ai';
import { logger } from '../utils/logger';
import { Database } from 'sqlite';
import { SensorData } from '../database/models/Sensor';

export interface FarmAnalysis {
  overallHealth: number;
  recommendations: string[];
  criticalIssues: string[];
  optimizationSuggestions: string[];
  timestamp: Date;
}

export interface AIResponse {
  analysis: FarmAnalysis;
  action: 'monitor' | 'alert' | 'optimize';
  confidence: number;
}

export class AIFarmManager {
  private genAI: GoogleGenerativeAI;
  private model: any;
  private db: Database;
  private lastAnalysis: Date | null = null;
  private readonly RATE_LIMIT_DELAY = 2000; // 2Ï¥à Í∞ÑÍ≤© (30 RPM Ï§ÄÏàò)

  constructor(db: Database, apiKey: string) {
    this.db = db;
    this.genAI = new GoogleGenerativeAI(apiKey);
    this.model = this.genAI.getGenerativeModel({ model: 'gemma-3-27b-it' });
    
    logger.info('ü§ñ AI Farm Manager initialized with Gemma 3 27B');
  }

  public async analyzeFarmCondition(sensorData: SensorData[]): Promise<AIResponse> {
    try {
      // Rate limiting check
      if (this.lastAnalysis && Date.now() - this.lastAnalysis.getTime() < this.RATE_LIMIT_DELAY) {
        logger.debug('Rate limit: Skipping AI analysis');
        return this.getDefaultResponse();
      }

      const prompt = this.buildAnalysisPrompt(sensorData);
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const analysisText = response.text();

      this.lastAnalysis = new Date();
      
      logger.info('üß† AI analysis completed');
      
      return this.parseAIResponse(analysisText, sensorData);
      
    } catch (error) {
      logger.error('AI analysis failed:', error);
      return this.getDefaultResponse();
    }
  }

  public async getOptimizationRecommendations(zoneId: string): Promise<string[]> {
    try {
      const zoneSensors = await this.getZoneSensorData(zoneId);
      const prompt = this.buildOptimizationPrompt(zoneId, zoneSensors);
      
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const recommendationsText = response.text();

      return this.parseRecommendations(recommendationsText);
      
    } catch (error) {
      logger.error('Failed to get optimization recommendations:', error);
      return ['ÏãúÏä§ÌÖú Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'];
    }
  }

  public async predictEnvironmentalTrends(hours: number = 24): Promise<{ 
    temperature: number[], 
    humidity: number[], 
    predictions: string[] 
  }> {
    try {
      const historicalData = await this.getHistoricalData(hours);
      const prompt = this.buildPredictionPrompt(historicalData);
      
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const predictionText = response.text();

      return this.parsePredictions(predictionText);
      
    } catch (error) {
      logger.error('Failed to predict environmental trends:', error);
      return { 
        temperature: [], 
        humidity: [], 
        predictions: ['ÏòàÏ∏° ÏãúÏä§ÌÖúÏù¥ ÏùºÏãúÏ†ÅÏúºÎ°ú ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.'] 
      };
    }
  }

  private buildAnalysisPrompt(sensorData: SensorData[]): string {
    const currentTime = new Date().toLocaleString('ko-KR');
    const sensorSummary = this.summarizeSensorData(sensorData);
    
    return `
ÎãπÏã†ÏùÄ Ï†ÑÎ¨∏Ï†ÅÏù∏ Ïä§ÎßàÌä∏Ìåú Í¥ÄÎ¶¨ AIÏûÖÎãàÎã§. Îã§Ïùå ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÏÑùÌïòÏó¨ ÎÜçÏû•Ïùò ÌòÑÏû¨ ÏÉÅÌÉúÎ•º ÌèâÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.

**ÌòÑÏû¨ ÏãúÍ∞Ñ**: ${currentTime}
**ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ ÏöîÏïΩ**:
${sensorSummary}

Îã§Ïùå ÌòïÏãùÏúºÎ°ú Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî:

**Ï†ÑÏ≤¥ Í±¥Í∞ïÎèÑ**: [0-100 Ï†êÏàò]
**Ï£ºÏöî Í∂åÏû•ÏÇ¨Ìï≠**:
- [Íµ¨Ï≤¥Ï†ÅÏù∏ Ï°∞ÏπòÏÇ¨Ìï≠ 1]
- [Íµ¨Ï≤¥Ï†ÅÏù∏ Ï°∞ÏπòÏÇ¨Ìï≠ 2]
- [Íµ¨Ï≤¥Ï†ÅÏù∏ Ï°∞ÏπòÏÇ¨Ìï≠ 3]

**Í∏¥Í∏â Î¨∏Ï†ú**:
- [Ï¶âÏãú Ìï¥Í≤∞Ïù¥ ÌïÑÏöîÌïú Î¨∏Ï†úÎì§]

**ÏµúÏ†ÅÌôî Ï†úÏïà**:
- [Ìö®Ïú®ÏÑ± Ìñ•ÏÉÅÏùÑ ÏúÑÌïú Ï†úÏïàÎì§]

**Î∂ÑÏÑù Ïã†Î¢∞ÎèÑ**: [0-100%]

ÌïúÍµ≠Ïñ¥Î°ú Ï†ÑÎ¨∏Ï†ÅÏù¥Í≥† Ïã§Ïö©Ï†ÅÏù∏ Ï°∞Ïñ∏ÏùÑ Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî.
`;
  }

  private buildOptimizationPrompt(zoneId: string, sensorData: SensorData[]): string {
    const zoneSummary = this.summarizeSensorData(sensorData);
    
    return `
${zoneId} Íµ¨Ïó≠Ïùò ÏµúÏ†ÅÌôî Î∞©ÏïàÏùÑ Ï†úÏïàÌï¥Ï£ºÏÑ∏Ïöî.

**Íµ¨Ïó≠ ÏÑºÏÑú ÌòÑÌô©**:
${zoneSummary}

**ÏöîÏ≤≠**: Ïù¥ Íµ¨Ïó≠Ïùò ÏÉùÏÇ∞ÏÑ±Í≥º ÏûëÎ¨º ÌíàÏßàÏùÑ Ìñ•ÏÉÅÏãúÌÇ§Í∏∞ ÏúÑÌïú Íµ¨Ï≤¥Ï†ÅÏù∏ ÏµúÏ†ÅÌôî Î∞©ÏïàÏùÑ 5Í∞ú Ïù¥ÌïòÎ°ú Ï†úÏïàÌï¥Ï£ºÏÑ∏Ïöî.

Í∞Å Ï†úÏïàÏùÄ Îã§ÏùåÏùÑ Ìè¨Ìï®Ìï¥Ïïº Ìï©ÎãàÎã§:
1. Íµ¨Ï≤¥Ï†ÅÏù∏ Ï°∞Ïπò Î∞©Î≤ï
2. ÏòàÏÉÅÎêòÎäî Ìö®Í≥º
3. Ïö∞ÏÑ†ÏàúÏúÑ (ÎÜíÏùå/Ï§ëÍ∞Ñ/ÎÇÆÏùå)

ÌïúÍµ≠Ïñ¥Î°ú Ïã§Ïö©Ï†ÅÏù∏ Ï°∞Ïñ∏ÏùÑ Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî.
`;
  }

  private buildPredictionPrompt(historicalData: any[]): string {
    return `
Îã§Ïùå 24ÏãúÍ∞Ñ ÎèôÏïàÏùò ÎÜçÏû• ÌôòÍ≤Ω Î≥ÄÌôîÎ•º ÏòàÏ∏°Ìï¥Ï£ºÏÑ∏Ïöî.

**Í≥ºÍ±∞ 24ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ìä∏Î†åÎìú**:
${JSON.stringify(historicalData.slice(0, 10), null, 2)}

Îã§Ïùå 24ÏãúÍ∞ÑÏùò Ïò®ÎèÑÏôÄ ÏäµÎèÑ Î≥ÄÌôî ÏòàÏ∏°Í≥º Ìï®Íªò, ÎÜçÏû• Í¥ÄÎ¶¨Î•º ÏúÑÌïú Ï£ºÏöî ÏòàÏ∏° Ìè¨Ïù∏Ìä∏Î•º Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî.

**ÌòïÏãù**:
**Ïò®ÎèÑ ÏòàÏ∏°**: [ÏãúÍ∞ÑÎåÄÎ≥Ñ ÏòàÏ∏°Í∞íÎì§]
**ÏäµÎèÑ ÏòàÏ∏°**: [ÏãúÍ∞ÑÎåÄÎ≥Ñ ÏòàÏ∏°Í∞íÎì§]
**Ï£ºÏöî ÏòàÏ∏°**:
- [ÏòàÏ∏° 1]
- [ÏòàÏ∏° 2]
- [ÏòàÏ∏° 3]

ÌïúÍµ≠Ïñ¥Î°ú Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî.
`;
  }

  private summarizeSensorData(sensorData: SensorData[]): string {
    const groupedData = sensorData.reduce((acc, data) => {
      const type = data.sensor_id.split('-').pop() || 'unknown';
      if (!acc[type]) acc[type] = [];
      acc[type].push(data);
      return acc;
    }, {} as Record<string, SensorData[]>);

    let summary = '';
    Object.entries(groupedData).forEach(([type, sensors]) => {
      const avgValue = sensors.reduce((sum, s) => sum + s.value, 0) / sensors.length;
      const normalCount = sensors.filter(s => s.status === 'normal').length;
      const warningCount = sensors.filter(s => s.status === 'warning').length;
      const criticalCount = sensors.filter(s => s.status === 'critical').length;
      
      const typeNames: Record<string, string> = {
        'temperature': 'Ïò®ÎèÑ',
        'humidity': 'ÏäµÎèÑ',
        'soil_moisture': 'ÌÜ†ÏñëÏàòÎ∂Ñ',
        'light': 'Ï°∞ÎèÑ',
        'co2': 'CO2'
      };

      summary += `${typeNames[type] || type}: ÌèâÍ∑† ${avgValue.toFixed(1)}${sensors[0]?.unit || ''} (Ï†ïÏÉÅ: ${normalCount}, Í≤ΩÍ≥†: ${warningCount}, ÏúÑÌóò: ${criticalCount})\n`;
    });

    return summary;
  }

  private parseAIResponse(analysisText: string, sensorData: SensorData[]): AIResponse {
    try {
      // Extract health score
      const healthMatch = analysisText.match(/Ï†ÑÏ≤¥ Í±¥Í∞ïÎèÑ.*?(\d+)/);
      const overallHealth = healthMatch ? parseInt(healthMatch[1]) : this.calculateBasicHealth(sensorData);

      // Extract recommendations
      const recommendations = this.extractListItems(analysisText, 'Ï£ºÏöî Í∂åÏû•ÏÇ¨Ìï≠');
      const criticalIssues = this.extractListItems(analysisText, 'Í∏¥Í∏â Î¨∏Ï†ú');
      const optimizationSuggestions = this.extractListItems(analysisText, 'ÏµúÏ†ÅÌôî Ï†úÏïà');

      // Extract confidence
      const confidenceMatch = analysisText.match(/Î∂ÑÏÑù Ïã†Î¢∞ÎèÑ.*?(\d+)/);
      const confidence = confidenceMatch ? parseInt(confidenceMatch[1]) : 85;

      const analysis: FarmAnalysis = {
        overallHealth,
        recommendations: recommendations.length > 0 ? recommendations : ['Ï†ïÍ∏∞Ï†ÅÏù∏ Î™®ÎãàÌÑ∞ÎßÅÏùÑ Í≥ÑÏÜçÌïòÏÑ∏Ïöî.'],
        criticalIssues: criticalIssues.length > 0 ? criticalIssues : [],
        optimizationSuggestions: optimizationSuggestions.length > 0 ? optimizationSuggestions : ['ÌòÑÏû¨ ÏÉÅÌÉúÍ∞Ä ÏñëÌò∏Ìï©ÎãàÎã§.'],
        timestamp: new Date()
      };

      const action: 'monitor' | 'alert' | 'optimize' = 
        criticalIssues.length > 0 ? 'alert' :
        overallHealth < 70 ? 'optimize' : 'monitor';

      return {
        analysis,
        action,
        confidence: confidence / 100
      };

    } catch (error) {
      logger.error('Failed to parse AI response:', error);
      return this.getDefaultResponse();
    }
  }

  private extractListItems(text: string, section: string): string[] {
    const sectionIndex = text.indexOf(section);
    if (sectionIndex === -1) return [];

    const afterSection = text.substring(sectionIndex);
    const nextSectionMatch = afterSection.match(/\*\*[^*]+\*\*/g);
    const endIndex = nextSectionMatch && nextSectionMatch.length > 1 ? 
      afterSection.indexOf(nextSectionMatch[1]) : afterSection.length;

    const sectionText = afterSection.substring(0, endIndex);
    const items = sectionText.match(/- (.+)/g);
    
    return items ? items.map(item => item.replace(/^- /, '').trim()) : [];
  }

  private parseRecommendations(text: string): string[] {
    const items = text.match(/^\d+\.\s*(.+)/gm) || text.match(/- (.+)/g);
    return items ? items.map(item => item.replace(/^\d+\.\s*|- /, '').trim()) : [text.trim()];
  }

  private parsePredictions(text: string): { temperature: number[], humidity: number[], predictions: string[] } {
    const predictions = this.extractListItems(text, 'Ï£ºÏöî ÏòàÏ∏°');
    
    return {
      temperature: [], // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî ÌååÏã± Î°úÏßÅ Ï∂îÍ∞Ä
      humidity: [],
      predictions: predictions.length > 0 ? predictions : ['ÏòàÏ∏° Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÏÑù Ï§ëÏûÖÎãàÎã§.']
    };
  }

  private calculateBasicHealth(sensorData: SensorData[]): number {
    if (sensorData.length === 0) return 85;
    
    const normalCount = sensorData.filter(s => s.status === 'normal').length;
    const warningCount = sensorData.filter(s => s.status === 'warning').length;
    const criticalCount = sensorData.filter(s => s.status === 'critical').length;

    const total = sensorData.length;
    const healthScore = (normalCount * 100 + warningCount * 60 + criticalCount * 20) / total;
    
    return Math.round(healthScore);
  }

  private getDefaultResponse(): AIResponse {
    return {
      analysis: {
        overallHealth: 85,
        recommendations: ['ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞Î•º Ï†ïÍ∏∞Ï†ÅÏúºÎ°ú Î™®ÎãàÌÑ∞ÎßÅÌïòÏÑ∏Ïöî.'],
        criticalIssues: [],
        optimizationSuggestions: ['AI Î∂ÑÏÑù ÏãúÏä§ÌÖúÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.'],
        timestamp: new Date()
      },
      action: 'monitor',
      confidence: 0.5
    };
  }

  private async getZoneSensorData(zoneId: string): Promise<SensorData[]> {
    try {
      return await this.db.all<SensorData[]>(`
        SELECT sd.* FROM sensor_data sd
        JOIN sensors s ON sd.sensor_id = s.id
        WHERE s.zone_id = ?
        AND sd.timestamp > datetime('now', '-1 hour')
        ORDER BY sd.timestamp DESC
      `, [zoneId]);
    } catch (error) {
      logger.error('Failed to get zone sensor data:', error);
      return [];
    }
  }

  private async getHistoricalData(hours: number): Promise<any[]> {
    try {
      return await this.db.all(`
        SELECT sensor_id, AVG(value) as avg_value, timestamp
        FROM sensor_data
        WHERE timestamp > datetime('now', '-${hours} hours')
        GROUP BY sensor_id, datetime(timestamp, 'localtime', 'start of hour')
        ORDER BY timestamp DESC
      `);
    } catch (error) {
      logger.error('Failed to get historical data:', error);
      return [];
    }
  }
}